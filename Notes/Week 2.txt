LINQ:
    - extension methods for IEnumerable
    - 2 versions of every link extension method
        - IEnumerable
            - runs in CLR with .NET objects
            - linq to objects
        - IQueryable
            - can be converted to some different way to get data like an sql query
            - linq to sql or linq to xml
    - 3 Types of LINQ methods:
        - Return a new IEnumerable Collection - uses deferred execution - will wait to get data, dont modify original collection
        - Return any concrete value - doesnt use deferred data
            - Average, First
        - Return collections that need to be "all there" - doesnt use defrred execution - gets all data right now
            - ToArray, ToList
    - Query syntax
        - like an sql query
            - from score in scores
              where score > 80
              select score;
    - Method syntax
        - uses a method and lambda
            - scores.Where(x => x > 80);

Azure:
    - Manage Azure
        - Azure portal
        - Azure CLI
        - VS & VS Code
    - Everything needs to be parts of "resource group"
        - We create : Resource Group > SQL Server > SQL Database
            - Every resource groups is part of a subscription
            - Database name scoped within resource group
            - Server name must be unique

Data:
    - .Net
        - Classes / Objects / Collections
        - Fields/Variables to store referenced to other data
    - Text formats like xml/json
        - heirarchical containers with attributes
    - Relational Database
        - Like a spreadsheet
            - no heirarchical structure
        - Represent identity with primary keys
        - Represent relationships with foreign keys
        - Tables / rows / columns
            - Unnormalized
                - Update anomaly : you modify all copies but miss one and data becomes inconsistant
                - Deletion anomaly : you delete one piece of data and it deletes additional data because of db structure
                - Insertian anomaly : your unable to store certain pieces of data without also having others
                - Slow searching / performance issues because unstructured data
            - Normalized : taking from unstructured to structured and follow rules
                - 6 Normal Forms : 1-3 are the practical ones
                    - 1NF
                        - all elements are atomic values, not lists/groups/sets. break them up to more rows
                        - each row must be unique
                        - adding new columns to split groups is not motivated and informally violates 1NF
                    - 2NF
                        - all cols which are not part of any candidate key, cannot have partial Dependency on any of the candidate keys
                        - all have to be fully dependent on every can candidate key
                        - if no composite keys, 1NF implies 2NF
                    - 3NF
                        - no non-CanKey column can depend on any other non-CanKey column
                        - No Transitive Dependency
                            - an indirect Dependency A -> B, B -> C so dep from A -> C

Referential Integrity: no broken references
    - every foreign key value should actually point to somthing in another table

Functional Dependency: a relationship between two pieces of data or attributes : (X -> Y) y is dependent on xs
    - for any value of X theres only one possible value of Y
    - Could be sets of columns not just individual columns

    - Candidate Key : a minimal set of col/attr that every other column is dependent on
        - minimal size : (not (name, phone) only (name) or (phone))
        - often set is just size 1 
        - the values of anu Candidate key can uniquely identify that row
            - if key has multiple columns, also can be called a composite key
    - Primary Key : one of the canidate keys to be official identifier
        - underline column to show its primary key
    - Foreign Key : a copy of the primary key to reference the row in another table

Entity Framework:
    - ORM: Object Relational Mapper
        - software that translates between sql and object oriented data/operations
    - Scaffold
        - Create classes from sql tables
    - EF Classes 
        - DbContext : represents the database
            - has many properties (at least 1 per table) which are DbSets
        - DbSet : represents a table
    - Datebase-First
        - create sql db first then use EF to generate code
        - modify databse first then regerate instead of changing classes
    - Code-First
        - write model by hand and use EF to generate migrations
        - modify classes then migrate to databse

Logging:
    - 6 Levels of loggings
        - Trace = 0, Debug = 1, Information = 2, Warning = 3, Error = 4, Critical = 5, None = 6

SQL : Structured Query Language
    - allows very abstract operations in a relation db
    - Variants:
        - MySQL
        - PostgreSQL - open source
        - Oracle SQL - used by java
        - SQLite - lightweight
        - *SQL Server (Transact-SQL) - Microsoft .NET
            - sql server is software/runtime
            - t-sql is language
            - connects to .NET with Object-relational mapper(ORM)
                - ORM is called Entity Framework
        - Data Manipulation Language (DML)
            - SELECT, INSERT, UPDATE, DELETE, TRUNCATE
            - these commands all operate on rows of tables.
        - Data Definition Language
            - CREATE, ALTER, DROP
            - these commands operate on other objects, like entire tables, or functions, views, etc.
        - Data Control Language (DCL) manages permissions/users/auth
            - GRANT, REVOKE
    - Semi colons (;) not requires
    - Line breaks and spacing doesnt matter
    - Not case sensitive
    - Single Quotes '' = VARCHAR or string literal
    - Double Quotes " " = Group data : could also use [full name]
    - = NULL is always false (even NULL = NULL)
        - Use IS NULL or IS NOT NULL to check
    - Comments:
        - -- (2 dashes) single line commeny
        - /**/ block comment
    - Operators:
        - OPS : < <= = >= >
        - Not equals : != or <>
        - Boolean : AND OR NOT
    - collation
        - database-wide settings for things like:
        - what encoding to use for non-Unicode strings
        - what currency symbol
        - what decimal point (,/.)
        - what default date format
        - whether (& how) strings compare (with case sensitivity, or not)
  
    ---------REFER TO SQL TEST FILES FOR MORE INFO---------
    Data Types:
        - numeric types
            - whole number
                - TINYINT (1-byte)
                - SMALLINT (2-byte)
                - INT (4-byte) - use unless having good reason
                - BIGINT (8-byte)
            - floating-point numbers
                - FLOAT, REAL
                - DECIMAL(n,p) aka NUMERIC(n,p)
                    - "n" is the number of digits
                    - "p" is the number of digits after the decimal point
                    - e.g. NUMERIC(10,2) would store numbers like 12345678.99
            - currency
                - MONEY, SMALLMONEY
                -  high precision, display with a $ (or something else depending on collation)
        - boolean
            - BIT (0 or 1)
        - string/text types
            - CHAR(n)     fixed-length non-Unicode string
            - VARCHAR(n)  variable length up to n, non-Unicode string
            - NCHAR(n)    fixed-length, Unicode string
            - NVARCHAR(n) variable-length Unicode string - use unless with good reason
            - we've got a variety of functions for strings e.g. LEN, SUBSTRING,
                - CHARINDEX, REPLACE, LOWER, UPPER
            - (indexing in SQL is 1-based, not 0-based)
        - date/time
            - DATE for dates
            - TIME for times
            - DATETIME(p) - stores both date and time
            -    can't store a very wide range of dates
            - DATETIME2(p) - store date and time with wide range, variable precision
            - DATETIMEOFFSET - for storing intervals of time
            - can extract parts of the dates/times using functions like YEAR(),
            - DATEPART(YEAR FROM '2019-01-01') or DATEPART(YEAR, '2019-01-01')
        - binary
            - binary
            - varbinary
    Queries:
        - SELECT statement:
            - Get data from table
            - Returns a results set not a table
        - INSERT statement:
            - insert values into table
        - UPDATE statement:
            - modify value in table
            - SET  to change values
        - DELETE:
            - delete a single row
        - TRUNCATE:
            - deletes all rows in table
    - Joins: allow a query to access serveral tables at once
        - Join condition is mostly foreign key to primary key
        - INNER JOIN:
            - Only include rows from each table that match search
        - LEFT JOIN:
            - Include all of left table and only those from right that match
        - RIGHT JOIN:
            - Include those from left that match and all of right
        - FULL JOIN:
            - Inlcude everything from both
        - Cross JOIN:
            - Every item from left to every item to right
    - Set Operators: Like joins but uses the results of a select instead of 2 tables data
        - Both queries Must have same num of cols and data types
        - UNION:
            - gives all rows that are found in either query without duplicates
        - UNION ALL:
            - gives all rows even duplicates
        - INTERSECT:
            - all rows in both queries no duplicates
        - EXCEPT:
            - all rows in first but not second
    - Sub Queries:
        - Run query based on condition of another query
        - Operators:
            - IN, NOT IN, EXISTS, ANY, ALL
        - Common Table Expression (CTE):
            - run a query in advance and put result in temp var to be used in main query
    - Constraints
        -- any column by default could contain NULL
        --      writing NULL makes default explicit
        -- NOT NULL - restrict column from being NULL
        -- UNIQUE - prevent any duplicates
        --		good for candidate keys, can be applied to sets of columns
        --		good for representing 1-to-1 replationship with foreign key
        -- PRIMARY KEY - set the primary for the table
        --		auto applies UNIQUE and NOT NULL
        --      but usually right NOT NULL anyway to be explicit
        -- CHECK - put any expression in () after this and that expression needs to be true for every row
        -- DEFAULT - sets a defualt value if an INSERT is done without one
        --		doesnt have to be constant - is evaluated at insert time
        -- IDENTITY(start, offset) - sets auto incrementing default number
        -- FOREIGN KEY
    - Indexes
        - data structures that we can have sql server maintain during writes so that reads can be faster
        - you want indexes on columns or sets of columns that usually reference in JOIN or WHERE conditions (foreign key good candidate)
        - SQL Server Types:
            - Clustered index:
                - tells sql server what order to 'physically' arrange the table in
                - fastest index, but there can only be 1
                - by default PRIMARY KEY sets CLUSTERED INDEX
            - Nonclustered index
                - maintains a seperate data structure kinda like an index at the end of an encylopedia
                - we can have many of these
                - UNIQUE sets nonclustered index by default
    - Computed columns:
        - value is computed when read not Stored
        - PERSISTED:
            - value is stored but no recomputed until it needs to be
            - FirstLetter AS SUBSTRING(Name, 1,1) PERSISTED
    - Computed Tables: views
        - can treat view as table
        - CREATE VIEW item AS SELECT statement;
    - Variables: scalar or tabled variables
        - only exist for duration of batch
        - split queries into serval parts
        - store inmediate values
        - ex.  DECLARE @name INT;
               SELECT @name = SELECT name FROM Custermer WHERE id = 1; can also use SET
        - ex.  DECLARE @mytable AS TABLE(
            stuff
        )
    - User defined functions: read only to db
        - cannot modify db
        - pretty much just SELECT
        - scalar
            - returns single value
        - tabled value
            - returns table with info
    - Stored Procedure:
        - like functions except can modify db
        - cant run them without EXECUTE
        - dont have return values, but have out parameters
        - need a variable to have procedure output return to
    - Trigger
        - some code that will run INSTEAD OF or AFTER you INSERT, UPDATE, or DELETE
        - function that runs after event on table
    - Transactions:
        - creates a single unit of work
            - all statements in block must succeed for all to succeed
        - BEGIN TRANSACTION stuff COMMIT TRANSACTION
            - can ROLLBACK TRANSACTION if error so none of statements go through
            - can make SAVEPOINTS in long transactions so dont have to redo everything can go back to try a certain part
        - in t-sql every statement is a transactions unto itself with auto rollback
        - ACID : (Atomicity, Consistency, Isolation, Durability)
            - Atomicity : succeed entirely or doesnt make any changes at all
            - Consistency : not violate any db constraints
            - Isolation : multiple transactions should be isolated and shouldnt affect the others
            - Durability : transactions not complete until its been persisted to non volatile memory
    Isolation:
        - anomalies: issues without isloation
            - dirty read : when this transaction see uncommitted data from another transaction
            - non repeatable read : read same row twice but values different cause another transaction modified it
            - phantom read : run same query twice and see new rows second time cause another transaction
        - Isolation levels: higher iso level slower performance and higher chance of deadlock
            - read_uncommitted : allows dity read
            - read_committed : doesnt allow dirty reading but allows others - default
            - repeatable : prevent non readble read and dirty read
            - serializable : prevents all



----------------------------------------------------
-LINQ (IEnumerable, IQueryable)
-Logging
-RDBMS (Table, Row, Column, PK, FK, Referential Integrity, Multiplicity)
-Normalization (Anomalies, Dependency, Candidate Key, 1NF, 2NF, 3NF)
-DML (Select, Insert, Update, Delete, Truncate)
-DDL (Create, Alter, Drop)
-Constraints (PK, FK, Unique, Check, Null, Not-Null, Default)
-JOIN (Inner-Join, Left-Join, Right-Join, Full-Join, Cross-Join, Self-Join)
-UNION (Union, Union-All, Intersect, Except)
-Subquery (CTE, Using-From, Using-Where)
-Aggregate (Average, Count, Sum, Min, Max)
-View (Schema-Binding)
-Function (Parameter, Scalar, Tabular)
-Stored Procedure (Variable, If-Else, Try-Catch, Throw, RaiseError, Print)
-Trigger (For, After, Instead-Of, Insert, Update, Delete)
-ACID (Atomicity, Consistency, Isolation, Durability)
-Transaction (Commit, Rollback, Savepoint)
-Isolation (Read-Uncommitted, Read-Committed, Repeatable-Read, Serializable)
-ORM (Entity Framework)
-EF model (Code-First Approach, Database-First Approach, DbContext, DbSet)
-EF querying (Eager Loading, Lazy Loading, Explicit Loading, LINQ, Deferred Execution)
-EF saving (Tracking, SaveChanges)
-Design Techniques (Repository-Pattern)